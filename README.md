---
title: Programming of C test

---

# 💻 C 語言學習與題目練習紀錄

這是我記錄 C 語言基礎語法練習的倉庫，內容包含原始碼與邏輯流程圖。

## 🛠️ 開發環境
* **Device:** MacBook Pro (M4 Pro)
* **Editor:** Visual Studio Code
* **Compiler:** Clang / GCC
* **Note:** 同步使用 Obsidian 、 HackMD 建立個人知識體系

---

## 📚 題目進度表

| 題號 | 題目名稱 | 原始碼 | 邏輯流程圖 | 備註 |
| :--- | :--- | :--- | :--- | :--- |
| **P1-1** | 水仙花數搜尋 | [Code](./Syntax_test/p1-1.c) | [Flowchart](./diagrams/p1-1.png) | 🟢 運用 `for` 迴圈在 100-999 區間自動搜尋符合定義之數值。 |
| **P1-2** | 水仙花數判定 | [Code](./Syntax_test/p1-2.c) | [Flowchart](./diagrams/p1-2.png) | 🟡 練習使用 `/` 與 `%` 運算子拆解三位數之位數。 |


---

### 📝 詳細解題筆記 (HackMD)
[![HackMD](https://img.shields.io/badge/Markdown-HackMD-blue?style=for-the-badge&logo=markdown)](https://hackmd.io/@rgyu-gao/BJy1cGRUge)
> **點擊上方圖片或 [這裡](https://hackmd.io/@rgyu-gao/BJy1cGRUge) 來閱讀詳細的解題過程與心得。**

> **也可以往下瀏覽詳細的解題過程與心得！！！**
---

## 📅 學習日誌
* **2026-02-09:** 完成 GitHub 倉庫結構化整理，建立 `Syntax_test` 與 `diagrams` 分類；上傳第一個練習題。
* **2026-02-24：** 完成 HackMD 與 GitHub 儲存庫 Coding-study-C 的同步設定，將學習心得整合至 main 分支並優化 README.md 專案簡介；上傳第二個練習題。




# 1. 水仙花數
## 題目
    打印出100~1000以內的所有水仙花數。
    所謂的水仙花數是指一個三位數，其各位數字立方和等於該數本身。
    

### 解法(一)  列印出100~1000之所有水仙花數。
        
```c=
/*
    vscode：p1_1
    
    打印出100~1000以內的所有水仙花數。
    ex：
        153是1個水仙花數
        因為153 = 1的3次方 + 5的3次方 + 3的3次方。
*/

#include <stdio.h>
#include <stdlib.h>
int main(void){
    
    int num=0;

    for(num=100;num<1000;num++){

    int g = num % 10;       // 個位
    int s = num / 10 % 10;  // 十位
    int b = num / 100;      // 百位
    
    int g3 = g * g * g;
    int s3 = s * s * s;
    int b3 = b * b * b;

    if((g3 + s3 + b3) == num)
        printf("num(%d) 是水仙花數\n",num);
    }        

    return 0;
}
```


### 解法(二)  輸入3位數數值，即可求得該數值是否為水仙花數。 

```c=
/* 
     vscode：p1_2
     
     輸入3位數數值，即可求得該數值是否為水仙花數。
*/

#include <stdio.h>
#include <stdlib.h>
int main(void){
    
    int num;
    printf("輸入一個數(100~999)：\n");
    scanf("%d",&num);

    if(num < 100 || num > 999){
        printf("輸入錯誤!!!");
        return 0;
    }
        
    int g = num % 10;        // 個位
    int s = num / 10 % 10;   // 十位
    int b = num / 100;       // 百位
    
    int g3 = g * g * g;
    int s3 = s * s * s;
    int b3 = b * b * b;

    if((g3 + s3 + b3) == num)
        printf("num(%d) 是水仙花數\n",num);
    else
        printf("num(%d) 不是水仙花數\n",num);

    return 0;
}
```


### 解法(文字敘述)
* 先設想如何將個、十、百位數單獨拆分出來。
* 根據題意，其各位數字立方和等於該數本身；則另外設3值代表各位數字立方和。
* 判斷是否為水仙花數。
* 進行100~1000以內的循環。


### 過程反思
* 我的程式為什麼輸入1000會顯示是水仙花數？
    * Ans： 程式會錯誤地顯示 1000 是水仙花數的原因在於條件判斷的順序問題。
    * 詳述：
        * 這段程式碼中，先判斷是否為水仙花數，然後才檢查數字是否在有效範圍內。
        * 當你輸入 1000 時，計算的立方和為 1³ + 0³ + 0³ = 1，與原數不相等，但因為範圍檢查放在最後，程式直接進入「不是水仙花數」的分支，沒有顯示「輸入錯誤」。


```c=
// 輸入1000時會顯示是水仙花數之錯誤程式碼。

if ((g3 + s3 + b3) == num)
    printf("num(%d) 是水仙花數\n",num);

else if(num < 100 || num > 999)
    printf("輸入錯誤!!!");

else
    printf("num(%d) 不是水仙花數\n",num);
```


* 如何修正？
    * Ans： 將範圍檢查放在最前面，這樣可以避免不必要的計算，並正確提示使用者。
    

---


# 2. 尋找完美數
## 題目

請用讓使用者輸入一個正整數 N，然後程式需要：
找出並印出 1 到 N 之間所有的完美數。
如果這個區間內沒有任何完美數，請印出一段提示訊息（"在這個範圍內沒有完美數"）。

一個正整數如果剛好等於它所有「真因數」（也就是除了自己以外的因數）的總和，這個數就被稱為「完美數」。

### 解法(一)  找出並印出 1 到 N 之間所有的完美數。
        
```c=
/*
vscode：p2_1

一個正整數如果剛好等於它所有「真因數」（也就是除了自己以外的因數）的總和，這個數就被稱為「完美數」。

請讓使用者輸入一個正整數 N，然後程式需要：
找出並印出 1 到 N 之間所有的完美數。
如果這個區間內沒有任何完美數，請印出一段提示訊息（"在這個範圍內沒有完美數"）。
*/

#include <stdio.h>
#include <stdlib.h>
int main(){
    int i,j,op,n;
    int null = 0;
    printf("enter n numbers:");
    scanf("%d",&n);

    printf("1 到 %d 之間所有的完美數:\n",n);

    for(i=1;i<=n;i++){

        op = 0;

        for(j=1;j<i;j++){
            if(i % j == 0){
                op = op + j;
            }
        }

        if(op == i){
            printf("%d ",i);
            null = 1;
        }
    }

    if(null == 0){
        printf("在這個範圍內沒有完美數");
    }

    return 0;
}
```


### 解法(二) ------優化後

```c=
/*
vscode：p2_2

一個正整數如果剛好等於它所有「真因數」（也就是除了自己以外的因數）的總和，這個數就被稱為「完美數」。

請讓使用者輸入一個正整數 N，然後程式需要：
找出並印出 1 到 N 之間所有的完美數。
如果這個區間內沒有任何完美數，請印出一段提示訊息（"在這個範圍內沒有完美數"）。
*/

#include <stdio.h>
#include <stdlib.h>

int main() {
    int n, fg = 0;
    printf("請輸入正整數 N: ");
    scanf("%d", &n);

    printf("1 到 %d 之間的完美數有：\n", n);

    for (int i = 2; i <= n; i++) { // 1 不是完美數，從 2 開始
        int op = 0;
        
        // 優化：因數最大只會到 i/2
        for (int j = 1; j <= i / 2; j++) {
            if (i % j == 0) {
                op += j;
            }
        }

        if (op == i) {
            printf("%d ", i);
            fg = 1;
        }
    }

    if (!fg) {
        printf("在這個範圍內沒有完美數");
    }

    return 0;
}
```


### 解法(文字敘述)
* 先設定n值並儲存。
* 接著開始找真因數
    * 先設一個i值，再設j值（因為要找的數不只一個，1~n）
    * i值是當前程式在進行運算的值，j值是i值從1~i中的所有數（不包含i值）
    * 從前面所述後，要找出真因數我們要先去思考哪些條件可以：當i除以j的餘數為0時。
* 現在我們成功找到真因數後，我們就要把他們加起來（即op = op + j;），設其為“可能是的完美數”。
* 接著判斷“可能是的完美數”是否真的是完美數（if(op == i)），是的話便將null設定為1（null是額外加的「標記」，用來記錄到底有沒有找到完美數）。
    * 記得要在邁入第二個迴圈時，將“可能是的完美數（op）”歸零（這樣當外層迴圈準備檢查下一個新數字時，op才會是一個乾淨的0，不會被上一個數字的因數總和干擾。）
* 最後如果非完美數，輸出"在這個範圍內沒有完美數"。

        ps:“可能是的完美數”即是因數總和。

### 過程反思
```c=
    // 原錯誤代碼

        for(j=1;j<i;j++){
            if(i % j == 0){
                op = j; 
            }
        }
```

* 每次找到新的因數，舊的因數就會被蓋掉，為何op只會記住最後一個找到的因數？
    * Ans：在程式碼裡，op = j; 的意思是「把找到的因數 j 存進 op 裡面」，這樣會造成每次找到新的因數，舊的因數就會被蓋掉，所以 op 最後只會記住最後一個被找到的因數。
    * 詳述：
        * 完美數需要的是因數的「總和」，要先思考怎麼修改那行程式碼，讓 op可以把每次找到的j都加起來，不斷累積。
        * 為了避免上一個數字的因數總和干擾到下一個數字，應該在程式中把op歸零。
* 如何修正？
    * Ans：先設定op為零，如果 j 是 i 的因數，就把 j 加上op累積起來成新的op，直到該迴圈結束即可得到“可能是的完美數”。

```c=
        // 每次檢查一個新的數字 i 之前，要把“可能是的完美數”歸零
        op = 0;

        for(j=1;j<i;j++){
            if(i % j == 0){
                // 如果 j 是 i 的因數，就把 j 加上去累積起來
                op = op + j; // 這行也可以簡寫成 op += j;
            }
        } 
```

---


# 💻 C 語言學習與題目練習紀錄

這是我記錄 C 語言基礎語法練習的倉庫，內容包含原始碼與邏輯流程圖。

## 🛠️ 開發環境
* **Device:** MacBook Pro (M4 Pro)
* **Editor:** Visual Studio Code
* **Compiler:** Clang / GCC
* **Note:** 同步使用 Obsidian 、 HackMD 建立個人知識體系

---

## 📚 題目進度表

| 題號 | 題目名稱 | 原始碼 | 邏輯流程圖 | 備註 |
| :--- | :--- | :--- | :--- | :--- |
| **P1-1** | 水仙花數搜尋 | [Code](./Syntax_test/p1-1.c) | [Flowchart](./diagrams/p1-1.png) | 🟢 運用 `for` 迴圈在 100-999 區間自動搜尋符合定義之數值。 |
| **P1-2** | 水仙花數判定 | [Code](./Syntax_test/p1-2.c) | [Flowchart](./diagrams/p1-2.png) | 🟡 練習使用 `/` 與 `%` 運算子拆解三位數之位數。 |


---

### 📝 詳細解題筆記 (HackMD)
[![HackMD](https://img.shields.io/badge/Markdown-HackMD-blue?style=for-the-badge&logo=markdown)](https://hackmd.io/@rgyu-gao/BJy1cGRUge)
> **點擊上方圖片或 [這裡](https://hackmd.io/@rgyu-gao/BJy1cGRUge) 來閱讀詳細的解題過程與心得。**

> **也可以往下瀏覽詳細的解題過程與心得！！！**
---

## 📅 學習日誌
* **2026-02-09:** 完成 GitHub 倉庫結構化整理，建立 `Syntax_test` 與 `diagrams` 分類；上傳第一個練習題。
* **2026-02-24：** 完成 HackMD 與 GitHub 儲存庫 Coding-study-C 的同步設定，將學習心得整合至 main 分支並優化 README.md 專案簡介；上傳第二個練習題。




# 1. 水仙花數
## 題目
    打印出100~1000以內的所有水仙花數。
    所謂的水仙花數是指一個三位數，其各位數字立方和等於該數本身。
    

### 解法(一)  列印出100~1000之所有水仙花數。
        
```c=
/*
    vscode：p1_1
    
    打印出100~1000以內的所有水仙花數。
    ex：
        153是1個水仙花數
        因為153 = 1的3次方 + 5的3次方 + 3的3次方。
*/

#include <stdio.h>
#include <stdlib.h>
int main(void){
    
    int num=0;

    for(num=100;num<1000;num++){

    int g = num % 10;       // 個位
    int s = num / 10 % 10;  // 十位
    int b = num / 100;      // 百位
    
    int g3 = g * g * g;
    int s3 = s * s * s;
    int b3 = b * b * b;

    if((g3 + s3 + b3) == num)
        printf("num(%d) 是水仙花數\n",num);
    }        

    return 0;
}
```


### 解法(二)  輸入3位數數值，即可求得該數值是否為水仙花數。 

```c=
/* 
     vscode：p1_2
     
     輸入3位數數值，即可求得該數值是否為水仙花數。
*/

#include <stdio.h>
#include <stdlib.h>
int main(void){
    
    int num;
    printf("輸入一個數(100~999)：\n");
    scanf("%d",&num);

    if(num < 100 || num > 999){
        printf("輸入錯誤!!!");
        return 0;
    }
        
    int g = num % 10;        // 個位
    int s = num / 10 % 10;   // 十位
    int b = num / 100;       // 百位
    
    int g3 = g * g * g;
    int s3 = s * s * s;
    int b3 = b * b * b;

    if((g3 + s3 + b3) == num)
        printf("num(%d) 是水仙花數\n",num);
    else
        printf("num(%d) 不是水仙花數\n",num);

    return 0;
}
```


### 解法(文字敘述)
* 先設想如何將個、十、百位數單獨拆分出來。
* 根據題意，其各位數字立方和等於該數本身；則另外設3值代表各位數字立方和。
* 判斷是否為水仙花數。
* 進行100~1000以內的循環。


### 過程反思
* 我的程式為什麼輸入1000會顯示是水仙花數？
    * Ans： 程式會錯誤地顯示 1000 是水仙花數的原因在於條件判斷的順序問題。
    * 詳述：
        * 這段程式碼中，先判斷是否為水仙花數，然後才檢查數字是否在有效範圍內。
        * 當你輸入 1000 時，計算的立方和為 1³ + 0³ + 0³ = 1，與原數不相等，但因為範圍檢查放在最後，程式直接進入「不是水仙花數」的分支，沒有顯示「輸入錯誤」。


```c=
// 輸入1000時會顯示是水仙花數之錯誤程式碼。

if ((g3 + s3 + b3) == num)
    printf("num(%d) 是水仙花數\n",num);

else if(num < 100 || num > 999)
    printf("輸入錯誤!!!");

else
    printf("num(%d) 不是水仙花數\n",num);
```


* 如何修正？
    * Ans： 將範圍檢查放在最前面，這樣可以避免不必要的計算，並正確提示使用者。
    

---


# 2. 尋找完美數
## 題目

請用讓使用者輸入一個正整數 N，然後程式需要：
找出並印出 1 到 N 之間所有的完美數。
如果這個區間內沒有任何完美數，請印出一段提示訊息（"在這個範圍內沒有完美數"）。

一個正整數如果剛好等於它所有「真因數」（也就是除了自己以外的因數）的總和，這個數就被稱為「完美數」。

### 解法(一)  找出並印出 1 到 N 之間所有的完美數。
        
```c=
/*
vscode：p2_1

一個正整數如果剛好等於它所有「真因數」（也就是除了自己以外的因數）的總和，這個數就被稱為「完美數」。

請讓使用者輸入一個正整數 N，然後程式需要：
找出並印出 1 到 N 之間所有的完美數。
如果這個區間內沒有任何完美數，請印出一段提示訊息（"在這個範圍內沒有完美數"）。
*/

#include <stdio.h>
#include <stdlib.h>
int main(){
    int i,j,op,n;
    int null = 0;
    printf("enter n numbers:");
    scanf("%d",&n);

    printf("1 到 %d 之間所有的完美數:\n",n);

    for(i=1;i<=n;i++){

        op = 0;

        for(j=1;j<i;j++){
            if(i % j == 0){
                op = op + j;
            }
        }

        if(op == i){
            printf("%d ",i);
            null = 1;
        }
    }

    if(null == 0){
        printf("在這個範圍內沒有完美數");
    }

    return 0;
}
```


### 解法(二) ------優化後

```c=
/*
vscode：p2_2

一個正整數如果剛好等於它所有「真因數」（也就是除了自己以外的因數）的總和，這個數就被稱為「完美數」。

請讓使用者輸入一個正整數 N，然後程式需要：
找出並印出 1 到 N 之間所有的完美數。
如果這個區間內沒有任何完美數，請印出一段提示訊息（"在這個範圍內沒有完美數"）。
*/

#include <stdio.h>
#include <stdlib.h>

int main() {
    int n, fg = 0;
    printf("請輸入正整數 N: ");
    scanf("%d", &n);

    printf("1 到 %d 之間的完美數有：\n", n);

    for (int i = 2; i <= n; i++) { // 1 不是完美數，從 2 開始
        int op = 0;
        
        // 優化：因數最大只會到 i/2
        for (int j = 1; j <= i / 2; j++) {
            if (i % j == 0) {
                op += j;
            }
        }

        if (op == i) {
            printf("%d ", i);
            fg = 1;
        }
    }

    if (!fg) {
        printf("在這個範圍內沒有完美數");
    }

    return 0;
}
```


### 解法(文字敘述)
* 先設定n值並儲存。
* 接著開始找真因數
    * 先設一個i值，再設j值（因為要找的數不只一個，1~n）
    * i值是當前程式在進行運算的值，j值是i值從1~i中的所有數（不包含i值）
    * 從前面所述後，要找出真因數我們要先去思考哪些條件可以：當i除以j的餘數為0時。
* 現在我們成功找到真因數後，我們就要把他們加起來（即op = op + j;），設其為“可能是的完美數”。
* 接著判斷“可能是的完美數”是否真的是完美數（if(op == i)），是的話便將null設定為1（null是額外加的「標記」，用來記錄到底有沒有找到完美數）。
    * 記得要在邁入第二個迴圈時，將“可能是的完美數（op）”歸零（這樣當外層迴圈準備檢查下一個新數字時，op才會是一個乾淨的0，不會被上一個數字的因數總和干擾。）
* 最後如果非完美數，輸出"在這個範圍內沒有完美數"。

        ps:“可能是的完美數”即是因數總和。

### 過程反思
```c=
    // 原錯誤代碼

        for(j=1;j<i;j++){
            if(i % j == 0){
                op = j; 
            }
        }
```

* 每次找到新的因數，舊的因數就會被蓋掉，為何op只會記住最後一個找到的因數？
    * Ans：在程式碼裡，op = j; 的意思是「把找到的因數 j 存進 op 裡面」，這樣會造成每次找到新的因數，舊的因數就會被蓋掉，所以 op 最後只會記住最後一個被找到的因數。
    * 詳述：
        * 完美數需要的是因數的「總和」，要先思考怎麼修改那行程式碼，讓 op可以把每次找到的j都加起來，不斷累積。
        * 為了避免上一個數字的因數總和干擾到下一個數字，應該在程式中把op歸零。
* 如何修正？
    * Ans：先設定op為零，如果 j 是 i 的因數，就把 j 加上op累積起來成新的op，直到該迴圈結束即可得到“可能是的完美數”。

```c=
        // 每次檢查一個新的數字 i 之前，要把“可能是的完美數”歸零
        op = 0;

        for(j=1;j<i;j++){
            if(i % j == 0){
                // 如果 j 是 i 的因數，就把 j 加上去累積起來
                op = op + j; // 這行也可以簡寫成 op += j;
            }
        } 
```

---


